import {
  serial,
  integer,
  pgEnum,
  pgTable,
  text,
  timestamp,
  varchar,
  numeric,
  boolean,
  json,
} from "drizzle-orm/pg-core";

// Define enums once and reuse them as column builders. Use unique enum
// names to avoid collisions in Postgres (enums are global types).
const roleEnum = pgEnum("role_enum", ["manager", "mechanic", "admin"]);
const orderStatusEnum = pgEnum("order_status_enum", ["pending", "in_progress", "completed"]);
const invoiceStatusEnum = pgEnum("invoice_status_enum", ["draft", "sent", "paid"]);
const notificationTypeEnum = pgEnum("notification_type_enum", ["order_created", "order_completed", "invoice_sent", "invoice_paid"]);

/**
 * Core user table backing auth flow.
 * Extended with role-based access control for managers and mechanic.
 */
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  phone: varchar("phone", { length: 20 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: roleEnum("role").default("manager").notNull(),
  branchName: varchar("branchName", { length: 255 }), // For managers only
  isActive: boolean("isActive").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  // Postgres doesn't have MySQL's ON UPDATE CURRENT_TIMESTAMP by default.
  // We'll keep a default value and update `updatedAt` in application logic.
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

/**
 * Bike types with pricing for each branch
 * Created by branch managers, shared across the system
 */
export const bikeTypes = pgTable("bike_types", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(), // e.g., "Dراجة أطفال"
  nameEn: varchar("nameEn", { length: 255 }), // English name
  nameFr: varchar("nameFr", { length: 255 }), // French name
  price: integer("price").notNull(), // Price in cents (e.g., 1000 for 10€)
  createdBy: integer("createdBy").notNull(), // Manager ID who created it
  isActive: boolean("isActive").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
});

export type BikeType = typeof bikeTypes.$inferSelect;
export type InsertBikeType = typeof bikeTypes.$inferInsert;

/**
 * Orders from branch managers to mechanic
 * Contains list of bikes to be assembled
 */
export const orders = pgTable("orders", {
  id: serial("id").primaryKey(),
  orderNumber: varchar("orderNumber", { length: 50 }).notNull().unique(), // Unique order ID (e.g., ORD-20250108-001)
  managerId: integer("managerId").notNull(), // Branch manager who created the order
  branchName: varchar("branchName", { length: 255 }).notNull(),
  status: orderStatusEnum("status").default("pending").notNull(),
  bikes: json("bikes").notNull(), // JSON array: [{bikeTypeId, quantity, barcode}, ...]
  notes: text("notes"), // Optional notes from manager
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
  completedAt: timestamp("completedAt"),
});

export type Order = typeof orders.$inferSelect;
export type InsertOrder = typeof orders.$inferInsert;

/**
 * Invoices generated by mechanic after completing orders
 */
export const invoices = pgTable("invoices", {
  id: serial("id").primaryKey(),
  invoiceNumber: varchar("invoiceNumber", { length: 50 }).notNull().unique(), // Auto-generated (e.g., INV-20250108-001)
  orderId: integer("orderId").notNull(), // Reference to order
  mechanicId: integer("mechanicId").notNull(), // Mechanic who created invoice
  managerId: integer("managerId").notNull(), // Branch manager
  branchName: varchar("branchName", { length: 255 }).notNull(),
  items: json("items").notNull(), // JSON array: [{bikeTypeName, quantity, unitPrice, total}, ...]
  totalAmount: integer("totalAmount").notNull(), // Total in cents
  paymentMethod: varchar("paymentMethod", { length: 100 }), // e.g., "Bank Transfer", "Cash"
  invoiceDate: timestamp("invoiceDate").defaultNow().notNull(),
  pdfUrl: varchar("pdfUrl", { length: 500 }), // S3 URL to PDF
  pdfKey: varchar("pdfKey", { length: 255 }), // S3 key for reference
  status: invoiceStatusEnum("status").default("draft").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
});

export type Invoice = typeof invoices.$inferSelect;
export type InsertInvoice = typeof invoices.$inferInsert;

/**
 * Notifications for real-time updates
 * Push notifications for order and invoice events
 */
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  recipientId: integer("recipientId").notNull(), // User receiving notification
  type: notificationTypeEnum("type").notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  body: text("body"),
  relatedOrderId: integer("relatedOrderId"), // Optional reference to order
  relatedInvoiceId: integer("relatedInvoiceId"), // Optional reference to invoice
  isRead: boolean("isRead").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Notification = typeof notifications.$inferSelect;
export type InsertNotification = typeof notifications.$inferInsert;

/**
 * Order items tracking (bikes scanned during assembly)
 * Used to track progress of order completion
 */
export const orderItems = pgTable("order_items", {
  id: serial("id").primaryKey(),
  orderId: integer("orderId").notNull(),
  bikeTypeId: integer("bikeTypeId").notNull(),
  quantity: integer("quantity").notNull(),
  completedQuantity: integer("completedQuantity").default(0).notNull(),
  barcodes: json("barcodes").notNull(), // JSON array of scanned barcodes: [{barcode, scannedAt}, ...]
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
});

export type OrderItem = typeof orderItems.$inferSelect;
export type InsertOrderItem = typeof orderItems.$inferInsert;

/**
 * Audit log for tracking all important actions
 */
export const auditLog = pgTable("audit_log", {
  id: serial("id").primaryKey(),
  userId: integer("userId").notNull(),
  action: varchar("action", { length: 100 }).notNull(), // e.g., "order_created", "invoice_sent"
  entityType: varchar("entityType", { length: 50 }).notNull(), // e.g., "order", "invoice"
  entityId: integer("entityId").notNull(),
  details: json("details"), // Additional context
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type AuditLog = typeof auditLog.$inferSelect;
export type InsertAuditLog = typeof auditLog.$inferInsert;
